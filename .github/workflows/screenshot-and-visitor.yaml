name: screenshot-and-visitor

on:
  push:
    branches: [main, master]
  schedule:
    - cron: '0 */2 * * *'
  workflow_dispatch:

permissions:
  contents: write
  pages: read
  actions: read

env:
  BADGE_STYLE: 'for-the-badge'
  BADGE_COLOR: 'brightgreen'
  LIKES_COLOR: 'gold'
  DATA_DIR: 'assets/db'
  SCREENSHOT_DIR: 'assets'

jobs:
  update-readme-and-visitor:
    runs-on: ubuntu-latest
    env:
      NODE_VERSION: '20.x'
      PUPPETEER_SKIP_CHROMIUM_DOWNLOAD: 'false'

    steps:
      - name: üî• Checkout repository
        uses: actions/checkout@v4
        with:
          persist-credentials: true
          fetch-depth: 0

      - name: üîç Check if screenshot is commented in README
        run: |
          if grep -q "^[[:space:]]*<!--.*üì∏ –°–∫—Ä—ñ–Ω—à–æ—Ç –ø—Ä–æ–µ–∫—Ç—É" README.md || grep -q "^[[:space:]]*<!--.*üì∏ Latest Screenshot" README.md; then
            echo "üì∏ Screenshot section is commented out - skipping screenshot generation"
            echo "SCREENSHOT_SKIP=true" >> $GITHUB_ENV
          else
            echo "üì∏ Screenshot section is active - proceeding with generation"
            echo "SCREENSHOT_SKIP=false" >> $GITHUB_ENV
          fi

      - name: üöÄ Initialize workflow
        run: |
          DATA_DIR="$DATA_DIR"
          SCREENSHOT_DIR="$SCREENSHOT_DIR"
          mkdir -p "$DATA_DIR" "$SCREENSHOT_DIR"

          awk '/<!-- AUTOGEN:STATS -->/{exit} {print}' README.md > README_before.tmp
          awk '/<!-- END:AUTOGEN -->/{found=1; next} found{print}' README.md > README_after.tmp

          {
            cat README_before.tmp
            echo "<!-- AUTOGEN:STATS -->"
            echo "üìÑ Updating statistics and screenshot..."
            echo "<!-- END:AUTOGEN -->"
            cat README_after.tmp
          } > README.md

          rm -f README_before.tmp README_after.tmp
          echo "üöÄ Workflow initialized, README cleared"

      - name: üìä Collect GitHub statistics
        run: |
          DATA_DIR="$DATA_DIR"
          STATS_FILE="$DATA_DIR/stats-data.json"
          USERS_FILE="$DATA_DIR/unique-users.json"
          STARGAZERS_FILE="$DATA_DIR/stargazers.json"
          OWNER=$(echo "${{ github.repository }}" | cut -d'/' -f1)
          REPO=$(echo "${{ github.repository }}" | cut -d'/' -f2)

          echo "üìä Collecting comprehensive GitHub statistics..."

          # –°—Ç–≤–æ—Ä—é—î–º–æ –¥–∏—Ä–µ–∫—Ç–æ—Ä—ñ—é –¥–ª—è –¥–∞–Ω–∏—Ö
          mkdir -p "$DATA_DIR"

          # === –û–°–ù–û–í–ù–ê –°–¢–ê–¢–ò–°–¢–ò–ö–ê –†–ï–ü–û–ó–ò–¢–û–†–Ü–Æ ===
          echo "üì¶ Fetching repository information..."
          REPO_INFO=$(curl -s -H "Authorization: token ${{ secrets.PAT_TOKEN }}" \
            "https://api.github.com/repos/$OWNER/$REPO")

          # –ó–±–µ—Ä—ñ–≥–∞—î–º–æ –ø–æ–≤–Ω—É —ñ–Ω—Ñ–æ—Ä–º–∞—Ü—ñ—é –ø—Ä–æ —Ä–µ–ø–æ–∑–∏—Ç–æ—Ä—ñ–π
          echo "$REPO_INFO" > "$DATA_DIR/repository-info.json"

          # === TRAFFIC STATISTICS ===
          echo "üëÄ Fetching traffic statistics..."
          TRAFFIC_VIEWS=$(curl -s -H "Authorization: token ${{ secrets.PAT_TOKEN }}" \
            "https://api.github.com/repos/$OWNER/$REPO/traffic/views")
          echo "$TRAFFIC_VIEWS" > "$DATA_DIR/traffic-views.json"

          TRAFFIC_CLONES=$(curl -s -H "Authorization: token ${{ secrets.PAT_TOKEN }}" \
            "https://api.github.com/repos/$OWNER/$REPO/traffic/clones")
          echo "$TRAFFIC_CLONES" > "$DATA_DIR/traffic-clones.json"

          TRAFFIC_POPULAR_PATHS=$(curl -s -H "Authorization: token ${{ secrets.PAT_TOKEN }}" \
            "https://api.github.com/repos/$OWNER/$REPO/traffic/popular/paths")
          echo "$TRAFFIC_POPULAR_PATHS" > "$DATA_DIR/traffic-popular-paths.json"

          TRAFFIC_POPULAR_REFERRERS=$(curl -s -H "Authorization: token ${{ secrets.PAT_TOKEN }}" \
            "https://api.github.com/repos/$OWNER/$REPO/traffic/popular/referrers")
          echo "$TRAFFIC_POPULAR_REFERRERS" > "$DATA_DIR/traffic-popular-referrers.json"

          # === STARGAZERS ===
          echo "‚≠ê Fetching stargazers information..."
          STARGAZERS_RESPONSE=$(curl -s -H "Authorization: token ${{ secrets.PAT_TOKEN }}" \
            "https://api.github.com/repos/$OWNER/$REPO/stargazers?per_page=100")

          if echo "$STARGAZERS_RESPONSE" | jq -e . >/dev/null 2>&1; then
            STARS_COUNT=$(echo "$STARGAZERS_RESPONSE" | jq 'length')
            STARGAZERS_DETAILED=$(echo "$STARGAZERS_RESPONSE" | jq '[.[] | {login: .login, avatar_url: .avatar_url, html_url: .html_url, starred_at: now | strftime("%Y-%m-%d %H:%M:%S")}]')
            echo "$STARGAZERS_RESPONSE" > "$DATA_DIR/stargazers-full.json"
          else
            STARS_COUNT=0
            STARGAZERS_DETAILED='[]'
            echo '[]' > "$DATA_DIR/stargazers-full.json"
          fi

          # === FORKS ===
          echo "üç¥ Fetching forks information..."
          FORKS_RESPONSE=$(curl -s -H "Authorization: token ${{ secrets.PAT_TOKEN }}" \
            "https://api.github.com/repos/$OWNER/$REPO/forks?per_page=100")
          echo "$FORKS_RESPONSE" > "$DATA_DIR/forks.json"
          FORKS_COUNT=$(echo "$FORKS_RESPONSE" | jq 'length')

          # === WATCHERS ===
          echo "üëÅÔ∏è Fetching watchers information..."
          WATCHERS_RESPONSE=$(curl -s -H "Authorization: token ${{ github.token }}" \
            "https://api.github.com/repos/$OWNER/$REPO/subscribers?per_page=100")
          echo "$WATCHERS_RESPONSE" > "$DATA_DIR/watchers.json"
          WATCHERS_COUNT=$(echo "$WATCHERS_RESPONSE" | jq 'length')

          # === CONTRIBUTORS ===
          echo "üë• Fetching contributors information..."
          CONTRIBUTORS_RESPONSE=$(curl -s -H "Authorization: token ${{ secrets.PAT_TOKEN }}" \
            "https://api.github.com/repos/$OWNER/$REPO/contributors?per_page=100")
          echo "$CONTRIBUTORS_RESPONSE" > "$DATA_DIR/contributors.json"
          CONTRIBUTORS_COUNT=$(echo "$CONTRIBUTORS_RESPONSE" | jq 'length')

          # === LANGUAGES ===
          echo "üî§ Fetching languages information..."
          LANGUAGES_RESPONSE=$(curl -s -H "Authorization: token ${{ secrets.PAT_TOKEN }}" \
            "https://api.github.com/repos/$OWNER/$REPO/languages")
          echo "$LANGUAGES_RESPONSE" > "$DATA_DIR/languages.json"

          # === RELEASES ===
          echo "üì¶ Fetching releases information..."
          RELEASES_RESPONSE=$(curl -s -H "Authorization: token ${{ secrets.PAT_TOKEN }}" \
            "https://api.github.com/repos/$OWNER/$REPO/releases")
          echo "$RELEASES_RESPONSE" > "$DATA_DIR/releases.json"

          TOTAL_DOWNLOADS=0
          if echo "$RELEASES_RESPONSE" | jq -e '. | length > 0' >/dev/null 2>&1; then
            TOTAL_DOWNLOADS=$(echo "$RELEASES_RESPONSE" | jq '[.[].assets[].download_count] | add // 0')
          fi

          # === COMMITS ===
          echo "üìù Fetching commits information..."
          COMMITS_RESPONSE=$(curl -s -H "Authorization: token ${{ secrets.PAT_TOKEN }}" \
            "https://api.github.com/repos/$OWNER/$REPO/commits?per_page=1")
          echo "$COMMITS_RESPONSE" > "$DATA_DIR/commits.json"
          COMMITS_COUNT=$(curl -s -H "Authorization: token ${{ secrets.PAT_TOKEN }}" \
            "https://api.github.com/repos/$OWNER/$REPO/commits?per_page=1" | grep -o 'rel="last"' | wc -l || echo "0")

          # === ISSUES ===
          echo "üêõ Fetching issues information..."
          ISSUES_RESPONSE=$(curl -s -H "Authorization: token ${{ secrets.PAT_TOKEN }}" \
            "https://api.github.com/repos/$OWNER/$REPO/issues?state=all&per_page=100")
          echo "$ISSUES_RESPONSE" > "$DATA_DIR/issues.json"
          OPEN_ISSUES=$(echo "$ISSUES_RESPONSE" | jq '[.[] | select(.state == "open")] | length')
          CLOSED_ISSUES=$(echo "$ISSUES_RESPONSE" | jq '[.[] | select(.state == "closed")] | length')

          # === PULL REQUESTS ===
          echo "üîÄ Fetching pull requests information..."
          PRS_RESPONSE=$(curl -s -H "Authorization: token ${{ secrets.PAT_TOKEN }}" \
            "https://api.github.com/repos/$OWNER/$REPO/pulls?state=all&per_page=100")
          echo "$PRS_RESPONSE" > "$DATA_DIR/pull-requests.json"
          OPEN_PRS=$(echo "$PRS_RESPONSE" | jq '[.[] | select(.state == "open")] | length')
          CLOSED_PRS=$(echo "$PRS_RESPONSE" | jq '[.[] | select(.state == "closed")] | length')
          MERGED_PRS=$(echo "$PRS_RESPONSE" | jq '[.[] | select(.merged_at != null)] | length')

          # === EXTRACT BASIC INFO FOR BADGES ===
          VIEWS=$(echo "$TRAFFIC_VIEWS" | jq '.uniques // 0')
          REPO_SIZE=$(echo "$REPO_INFO" | jq -r '.size // 0')
          REPO_SIZE_MB=$(echo "scale=1; $REPO_SIZE / 1024" | bc -l 2>/dev/null || echo "0")
          MAIN_LANGUAGE=$(echo "$REPO_INFO" | jq -r '.language // "Unknown"')
          LICENSE=$(echo "$REPO_INFO" | jq -r '.license.name // "No License"')

          # === CREATE BADGES ===
          echo '{"schemaVersion": 1, "label": "üìä views", "message": "'$VIEWS'", "color": "'$BADGE_COLOR'", "style": "'$BADGE_STYLE'"}' > "$DATA_DIR/visitors-badge.json"
          echo '{"schemaVersion": 1, "label": "‚≠ê stars", "message": "'$STARS_COUNT'", "color": "'$LIKES_COLOR'", "style": "'$BADGE_STYLE'"}' > "$DATA_DIR/likes-badge.json"
          echo '{"schemaVersion": 1, "label": "üç¥ forks", "message": "'$FORKS_COUNT'", "color": "blue", "style": "'$BADGE_STYLE'"}' > "$DATA_DIR/forks-badge.json"
          echo '{"schemaVersion": 1, "label": "üëÅÔ∏è watchers", "message": "'$WATCHERS_COUNT'", "color": "blue", "style": "'$BADGE_STYLE'"}' > "$DATA_DIR/watchers-badge.json"
          echo '{"schemaVersion": 1, "label": "üë• contributors", "message": "'$CONTRIBUTORS_COUNT'", "color": "green", "style": "'$BADGE_STYLE'"}' > "$DATA_DIR/contributors-badge.json"
          echo '{"schemaVersion": 1, "label": "üì¶ size", "message": "'${REPO_SIZE_MB}'MB", "color": "blue", "style": "'$BADGE_STYLE'"}' > "$DATA_DIR/repo-size.json"
          echo '{"schemaVersion": 1, "label": "üìÑ license", "message": "'$LICENSE'", "color": "blue", "style": "'$BADGE_STYLE'"}' > "$DATA_DIR/repo-license.json"
          echo '{"schemaVersion": 1, "label": "üìù commits", "message": "'$COMMITS_COUNT'", "color": "orange", "style": "'$BADGE_STYLE'"}' > "$DATA_DIR/commits-badge.json"

          if [ "$TOTAL_DOWNLOADS" -gt 0 ]; then
            echo '{"schemaVersion": 1, "label": "‚¨áÔ∏è downloads", "message": "'$TOTAL_DOWNLOADS'", "color": "orange", "style": "'$BADGE_STYLE'"}' > "$DATA_DIR/downloads-badge.json"
          fi

          # === TECH BADGES ===
          echo "üîß Generating technology badges..."
          TECH_BADGES=""

          if echo "$LANGUAGES_RESPONSE" | jq -e . >/dev/null 2>&1; then
            TOP_LANGUAGES=$(echo "$LANGUAGES_RESPONSE" | jq -r 'to_entries | sort_by(.value) | reverse | .[0:3] | .[].key')
            
            for lang in $TOP_LANGUAGES; do
              case $lang in
                "HTML") TECH_BADGES="$TECH_BADGES[![HTML5](https://img.shields.io/badge/HTML5-E34F26?style=for-the-badge&logo=html5&logoColor=white)](https://developer.mozilla.org/en-US/docs/Web/HTML) " ;;
                "CSS") TECH_BADGES="$TECH_BADGES[![CSS3](https://img.shields.io/badge/CSS3-1572B6?style=for-the-badge&logo=css3&logoColor=white)](https://developer.mozilla.org/en-US/docs/Web/CSS) " ;;
                "JavaScript") TECH_BADGES="$TECH_BADGES[![JavaScript](https://img.shields.io/badge/JavaScript-F7DF1E?style=for-the-badge&logo=javascript&logoColor=black)](https://developer.mozilla.org/en-US/docs/Web/JavaScript) " ;;
                "TypeScript") TECH_BADGES="$TECH_BADGES[![TypeScript](https://img.shields.io/badge/TypeScript-007ACC?style=for-the-badge&logo=typescript&logoColor=white)](https://www.typescriptlang.org/) " ;;
                "Python") TECH_BADGES="$TECH_BADGES[![Python](https://img.shields.io/badge/Python-3776AB?style=for-the-badge&logo=python&logoColor=white)](https://www.python.org/) " ;;
                "Java") TECH_BADGES="$TECH_BADGES[![Java](https://img.shields.io/badge/Java-ED8B00?style=for-the-badge&logo=java&logoColor=white)](https://www.java.com/) " ;;
              esac
            done
          fi

          TECH_BADGES="$TECH_BADGES[![Terminal](https://img.shields.io/badge/mac%20terminal-000000?style=for-the-badge&logo=apple&logoColor=white&labelColor=000000)](https://support.apple.com/guide/terminal/welcome/mac) "
          TECH_BADGES="$TECH_BADGES[![VS Code](https://img.shields.io/badge/VS_Code-007ACC?style=for-the-badge&logo=visual-studio-code&logoColor=white)](https://code.visualstudio.com/) "
          TECH_BADGES="$TECH_BADGES[![GitHub](https://img.shields.io/badge/GitHub-181717?style=for-the-badge&logo=github&logoColor=white)](https://github.com/) "
          TECH_BADGES="$TECH_BADGES[![Figma](https://img.shields.io/badge/Figma-F24E1E?style=for-the-badge&logo=figma&logoColor=white)](https://www.figma.com/) "

          echo "$TECH_BADGES" > "$DATA_DIR/tech-badges.txt"

          # === SAVE SUMMARY STATISTICS ===
          echo "üíæ Saving summary statistics..."
          echo "{
            \"updated_at\": \"$(date -u +"%Y-%m-%d %H:%M:%S")\",
            \"views\": $VIEWS,
            \"stars\": $STARS_COUNT,
            \"forks\": $FORKS_COUNT,
            \"watchers\": $WATCHERS_COUNT,
            \"contributors\": $CONTRIBUTORS_COUNT,
            \"commits\": $COMMITS_COUNT,
            \"open_issues\": $OPEN_ISSUES,
            \"closed_issues\": $CLOSED_ISSUES,
            \"open_prs\": $OPEN_PRS,
            \"closed_prs\": $CLOSED_PRS,
            \"merged_prs\": $MERGED_PRS,
            \"downloads\": $TOTAL_DOWNLOADS,
            \"repo_size_mb\": $REPO_SIZE_MB,
            \"main_language\": \"$MAIN_LANGUAGE\",
            \"license\": \"$LICENSE\"
          }" > "$STATS_FILE"

          echo "‚úÖ All GitHub statistics collected and saved!"
          echo "üìä Summary: Views=$VIEWS, Stars=$STARS_COUNT, Forks=$FORKS_COUNT, Contributors=$CONTRIBUTORS_COUNT"

      - name: üñ• Setup Node.js and dependencies
        run: |
          if [ "$SCREENSHOT_SKIP" = "true" ]; then
            echo "‚è≠Ô∏è Skipping Node.js setup - screenshot generation disabled"
            exit 0
          fi
          echo "üîß Setting up Node.js..."
          curl -fsSL https://deb.nodesource.com/setup_20.x | sudo -E bash -
          sudo apt-get install -y nodejs

          echo "Node.js version: $(node --version)"
          echo "npm version: $(npm --version)"

          echo "üåê Setting up Chrome..."
          wget -q -O - https://dl.google.com/linux/linux_signing_key.pub | sudo gpg --dearmor -o /usr/share/keyrings/google-chrome-keyring.gpg
          echo "deb [arch=amd64 signed-by=/usr/share/keyrings/google-chrome-keyring.gpg] http://dl.google.com/linux/chrome/deb/ stable main" | sudo tee /etc/apt/sources.list.d/google-chrome.list
          sudo apt-get update
          sudo apt-get install -y google-chrome-stable jq libgbm-dev

          echo "Chrome version: $(google-chrome-stable --version || echo 'Chrome not available')"

          echo "üì¶ Installing Puppeteer..."
          npm config set registry https://registry.npmjs.org/
          npm install --no-package-lock --no-save puppeteer@latest --timeout=120000

          if [ -d "node_modules/puppeteer" ]; then
            PUPPETEER_VERSION=$(node -e "console.log(require('./node_modules/puppeteer/package.json').version)")
            echo "‚úÖ Puppeteer is available: $PUPPETEER_VERSION"
            echo "SCREENSHOT_DEPENDENCIES_AVAILABLE=true" >> $GITHUB_ENV
          else
            echo "‚ùå Puppeteer could not be installed - screenshot functionality disabled"
            echo "SCREENSHOT_DEPENDENCIES_AVAILABLE=false" >> $GITHUB_ENV
          fi

      - name: üì∏ Generate screenshot from GitHub Pages
        run: |
          if [ "$SCREENSHOT_DEPENDENCIES_AVAILABLE" = "false" ]; then
            echo "‚ùå Screenshot dependencies not available - skipping screenshot"
            echo "SCREENSHOT_CREATED=false" >> $GITHUB_ENV
            exit 0
          fi

          if [ "$SCREENSHOT_SKIP" = "true" ]; then
            echo "‚è≠Ô∏è Screenshot generation skipped - section is commented out"
            echo "SCREENSHOT_CREATED=false" >> $GITHUB_ENV
            exit 0
          fi

          node -e "
          const puppeteer = require('puppeteer');
          const fs = require('fs');
          const path = require('path');
          const { execSync } = require('child_process');

          async function takeScreenshot() {
            let browser;
            try {
              const screenshotDir = process.env.SCREENSHOT_DIR || 'assets';
              const screenshotPath = path.resolve(screenshotDir, 'screenshot.png');
              
              if (!fs.existsSync(screenshotDir)) fs.mkdirSync(screenshotDir, { recursive: true });
              if (fs.existsSync(screenshotPath)) fs.unlinkSync(screenshotPath);
              
              let chromeExecutable = '/usr/bin/google-chrome';
              if (!fs.existsSync(chromeExecutable)) {
                try {
                  const chromePath = execSync('which google-chrome-stable || which google-chrome', { encoding: 'utf8' }).trim();
                  if (chromePath) chromeExecutable = chromePath;
                } catch (e) {
                  console.log('‚ùå Chrome not found:', e.message);
                  console.log('SCREENSHOT_SUCCESS=false');
                  return;
                }
              }

              console.log('Using Chrome executable:', chromeExecutable);
              
              const browserArgs = [
                '--no-sandbox',
                '--disable-setuid-sandbox',
                '--disable-dev-shm-usage',
                '--disable-web-security',
                '--disable-features=VizDisplayCompositor',
                '--headless',
                '--disable-gpu',
                '--disable-software-rasterizer',
                '--remote-debugging-port=0',
                '--no-zygote',
                '--no-first-run',
                '--disable-extensions',
                '--disable-background-timer-throttling',
                '--disable-backgrounding-occluded-windows',
                '--disable-renderer-backgrounding'
              ];

              browser = await puppeteer.launch({
                args: browserArgs,
                executablePath: chromeExecutable,
                timeout: 30000,
                dumpio: false
              });
              
              const page = await browser.newPage();
              await page.setViewport({ width: 1280, height: 800 });
              
              const githubPages = 'https://' + '${{ github.repository_owner }}' + '.github.io/' + '${{ github.event.repository.name }}' + '/';
              
              console.log('üåê Checking GitHub Pages availability...');
              console.log('üîó Target URL:', githubPages);
              
              try {
                const response = await page.goto(githubPages, { 
                  waitUntil: 'networkidle0', 
                  timeout: 30000 
                });
                
                if (!response || response.status() !== 200) {
                  console.log('‚ùå GitHub Pages returned status:', response?.status() || 'unknown');
                  console.log('SCREENSHOT_SUCCESS=false');
                  return;
                }
                
                const pageTitle = await page.title();
                const pageContent = await page.content();
                
                const hasMeaningfulContent = pageContent.length > 500 && 
                                           !pageTitle.includes('404') &&
                                           !pageContent.includes('There isn\\'t a GitHub Pages site here');
                
                if (!hasMeaningfulContent) {
                  console.log('‚ùå GitHub Pages has insufficient content');
                  console.log('SCREENSHOT_SUCCESS=false');
                  return;
                }
                
                console.log('‚úÖ GitHub Pages is accessible with meaningful content');
                console.log('üì∏ Taking screenshot...');
                
                await new Promise(resolve => setTimeout(resolve, 3000));
                
                await page.evaluate(() => {
                  return new Promise(resolve => {
                    let totalHeight = 0;
                    const distance = 200;
                    const timer = setInterval(() => {
                      const scrollHeight = document.body.scrollHeight;
                      window.scrollBy(0, distance);
                      totalHeight += distance;
                      
                      if (totalHeight >= scrollHeight) {
                        clearInterval(timer);
                        resolve();
                      }
                    }, 50);
                  });
                });
                
                await new Promise(resolve => setTimeout(resolve, 1000));
                await page.evaluate(() => window.scrollTo(0, 0));
                await new Promise(resolve => setTimeout(resolve, 1000));

                await page.screenshot({ 
                  path: screenshotPath, 
                  fullPage: true,
                  type: 'png'
                });
                
                if (fs.existsSync(screenshotPath)) {
                  const stats = fs.statSync(screenshotPath);
                  const fileSizeKB = Math.round(stats.size / 1024);
                  
                  if (stats.size > 1000) {
                    console.log('‚úÖ Screenshot created successfully:', fileSizeKB + 'KB');
                    console.log('SCREENSHOT_SUCCESS=true');
                  } else {
                    console.log('‚ùå Screenshot file is too small:', fileSizeKB + 'KB');
                    fs.unlinkSync(screenshotPath);
                    console.log('SCREENSHOT_SUCCESS=false');
                  }
                } else {
                  console.log('‚ùå Screenshot file was not created');
                  console.log('SCREENSHOT_SUCCESS=false');
                }
                
              } catch (screenshotError) {
                console.log('‚ùå Screenshot process failed:', screenshotError.message);
                console.log('SCREENSHOT_SUCCESS=false');
              }
              
            } catch (error) {
              console.log('‚ùå Browser setup failed:', error.message);
              console.log('SCREENSHOT_SUCCESS=false');
            } finally {
              if (browser) {
                try {
                  await browser.close();
                } catch (closeError) {
                  console.log('‚ö†Ô∏è Browser close error:', closeError.message);
                }
              }
            }
          }

          takeScreenshot().catch(error => {
            console.log('‚ùå Unhandled error in screenshot process:', error.message);
            console.log('SCREENSHOT_SUCCESS=false');
          });
          " | tee screenshot_output.log

          if grep -q "SCREENSHOT_SUCCESS=true" screenshot_output.log; then
            echo "SCREENSHOT_CREATED=true" >> $GITHUB_ENV
            echo "üéØ Screenshot created successfully"
          else
            echo "SCREENSHOT_CREATED=false" >> $GITHUB_ENV
            echo "‚è≠Ô∏è Screenshot creation failed"
          fi

          if [ -f "$SCREENSHOT_DIR/screenshot.png" ]; then
            FILE_SIZE=$(stat -f%z "$SCREENSHOT_DIR/screenshot.png" 2>/dev/null || stat -c%s "$SCREENSHOT_DIR/screenshot.png" 2>/dev/null || echo 0)
            if [ "$FILE_SIZE" -lt 1000 ]; then
              echo "‚ö†Ô∏è Screenshot file exists but is too small ($FILE_SIZE bytes), removing..."
              rm -f "$SCREENSHOT_DIR/screenshot.png"
              echo "SCREENSHOT_CREATED=false" >> $GITHUB_ENV
            fi
          fi

          rm -f screenshot_output.log

      - name: üìù Update README with all content
        run: |
          REPO_URL="https://raw.githubusercontent.com/${{ github.repository }}/${{ github.ref_name }}"
          TECH_BADGES=$(cat $DATA_DIR/tech-badges.txt 2>/dev/null || echo "")

          DOWNLOADS_BADGE=""
          if [ -f "$DATA_DIR/downloads-badge.json" ]; then
            DOWNLOADS_BADGE="[![‚¨áÔ∏è Downloads](https://img.shields.io/endpoint?url=$REPO_URL/$DATA_DIR/downloads-badge.json)](https://github.com/${{ github.repository }}/releases)"
          fi

          awk '/<!-- AUTOGEN:STATS -->/{exit} {print}' README.md > README_before.tmp
          awk '/<!-- END:AUTOGEN -->/{found=1; next} found{print}' README.md > README_after.tmp

          {
            cat README_before.tmp
            echo "<!-- AUTOGEN:STATS -->"
            echo "$TECH_BADGES"
            echo ""
            echo "[![üìä Views](https://img.shields.io/endpoint?url=$REPO_URL/$DATA_DIR/visitors-badge.json)](https://github.com/${{ github.repository }}/graphs/traffic)"
            echo "[![‚≠ê Stars](https://img.shields.io/endpoint?url=$REPO_URL/$DATA_DIR/likes-badge.json)](https://github.com/${{ github.repository }}/stargazers)"
            echo "[![üç¥ Forks](https://img.shields.io/endpoint?url=$REPO_URL/$DATA_DIR/forks-badge.json)](https://github.com/${{ github.repository }}/network/members)"
            echo "[![üëÅÔ∏è Watchers](https://img.shields.io/endpoint?url=$REPO_URL/$DATA_DIR/watchers-badge.json)](https://github.com/${{ github.repository }}/watchers)"
            echo "[![üë• Contributors](https://img.shields.io/endpoint?url=$REPO_URL/$DATA_DIR/contributors-badge.json)](https://github.com/${{ github.repository }}/graphs/contributors)"
            echo "[![üì¶ Size](https://img.shields.io/endpoint?url=$REPO_URL/$DATA_DIR/repo-size.json)](https://github.com/${{ github.repository }})"
            echo "[![üìÑ License](https://img.shields.io/endpoint?url=$REPO_URL/$DATA_DIR/repo-license.json)](https://github.com/${{ github.repository }}/blob/main/LICENSE)"
            echo "[![üìù Commits](https://img.shields.io/endpoint?url=$REPO_URL/$DATA_DIR/commits-badge.json)](https://github.com/${{ github.repository }}/commits/main)"
            if [ -n "$DOWNLOADS_BADGE" ]; then
              echo "$DOWNLOADS_BADGE"
            fi
            
            if [ "$SCREENSHOT_CREATED" = "true" ] && [ -f "$SCREENSHOT_DIR/screenshot.png" ]; then
              SCREENSHOT_SIZE=$(stat -f%z "$SCREENSHOT_DIR/screenshot.png" 2>/dev/null || stat -c%s "$SCREENSHOT_DIR/screenshot.png" 2>/dev/null || echo "0")
              if [ "$SCREENSHOT_SIZE" -gt 0 ]; then
                echo ""
                echo "## üì∏ –°–∫—Ä—ñ–Ω—à–æ—Ç –ø—Ä–æ–µ–∫—Ç—É"
                echo "![Project Screenshot](./$SCREENSHOT_DIR/screenshot.png)"
              fi
            fi
            
            echo "<!-- END:AUTOGEN -->"
            cat README_after.tmp
          } > README.md

          rm -f README_before.tmp README_after.tmp
          echo "‚úÖ README updated with all content"

      - name: üì§ Commit and deploy
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"
          git add .

          COMMIT_MSG="üìä Auto-update: GitHub statistics"
          if [ "$SCREENSHOT_CREATED" = "true" ]; then
            COMMIT_MSG="$COMMIT_MSG and screenshot"
          fi

          git commit -m "$COMMIT_MSG" || exit 0
          git push https://x-access-token:${{ secrets.GITHUB_TOKEN }}@github.com/${{ github.repository }}.git

          echo "üìÑ Triggering updates..."
          if curl -s -f -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
            "https://api.github.com/repos/${{ github.repository }}/pages" >/dev/null 2>&1; then
            curl -s -X POST -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
              "https://api.github.com/repos/${{ github.repository }}/pages/builds" >/dev/null || true
          fi

          echo "‚úÖ All updates completed successfully"